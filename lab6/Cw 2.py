#Знайти такі вершини, до яких є ребра від кожної іншої вершини, але від цієї вершини немає ребер до жодної вершини
#Представлення у вигляді матриці інцидентності

T = [[0, 0, 1, 0, 1, 0, 0],
     [1, 0, 0, 0, 1, 0, 0],
     [0, 1, 0, 1, 1, 1, 1],
     [0, 0, 0, 0, 1, 0, 0],
     [0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 1, 0, 0],
     [0, 0, 0, 0, 1, 0, 0]]

#O(N^2) moj
def find_1(T):
    ind = -1
    n = len(T)
    for i in range(n):
        o = True
        for j in range(n):
            if T[i][j] != 0:
                o = False
            if i != j and T[j][i] != 1:
                o = False
        if o:
            ind = i
    return ind

#Починаємо від T[0][0] і йдемо вправо, поки справа є 0, а коли ні, то спускаємося вниз і йдемо допоки не матимемо по
#правій стороні 0, і так поки не дійдемо до правої межі матриці. Перевіряємо цей елемент, чи він підходить, якщо так то
#це він, а якщо ні то його просто не існує.
#O(N)
def find_2(T):
    n = len(T)
    i = j = 0
    while i < n-1 and j < n-1:
        while j + 1 < n and T[i][j+1] == 0:
            j += 1
        while i < n-1 and j + 1 < n-1 and T[i][j+1] != 0:
            i += 1
    for k in range(n):
        if T[i][k] != 0:
            return False
        if k != i and T[k][i] != 1:
            return False
    return i

print(find_1(T))
print(find_2(T))
